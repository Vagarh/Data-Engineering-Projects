# Pipeline de Logstash para procesamiento de logs de seguridad

input {
  beats {
    port => 5044
  }
}

filter {
  # Agregar timestamp de procesamiento
  mutate {
    add_field => { "processing_timestamp" => "%{@timestamp}" }
  }

  # Procesamiento específico por tipo de log
  if [log_type] == "web" {
    # Parsear logs de Apache/Nginx
    grok {
      match => { 
        "message" => "%{IPORHOST:source_ip} %{USER:ident} %{USER:auth} \[%{HTTPDATE:timestamp}\] \"(?:%{WORD:method} %{URIPATH:path}(?:%{URIPARAM:params})?(?: HTTP/%{NUMBER:http_version})?|%{DATA:rawrequest})\" %{NUMBER:status_code} (?:%{NUMBER:response_size}|-) \"(?:%{DATA:referer}|-)\" \"(?:%{DATA:user_agent}|-)\""
      }
    }
    
    # Convertir campos numéricos
    mutate {
      convert => { 
        "status_code" => "integer"
        "response_size" => "integer"
      }
    }
    
    # Detectar patrones de ataque web
    if [path] =~ /(?i)(union|select|insert|delete|drop|script|alert|javascript)/ {
      mutate {
        add_tag => ["sql_injection_attempt", "web_attack"]
        add_field => { "threat_type" => "web_attack" }
      }
    }
    
    if [user_agent] =~ /(?i)(sqlmap|nikto|nmap|curl|wget|python-requests)/ {
      mutate {
        add_tag => ["suspicious_user_agent", "web_attack"]
        add_field => { "threat_type" => "automated_tool" }
      }
    }
    
    # Categorizar códigos de estado
    if [status_code] >= 400 and [status_code] < 500 {
      mutate {
        add_tag => ["client_error"]
      }
    } else if [status_code] >= 500 {
      mutate {
        add_tag => ["server_error"]
      }
    }
    
    # GeoIP lookup
    geoip {
      source => "source_ip"
      target => "geoip"
    }
  }
  
  else if [log_type] == "firewall" {
    # Parsear logs JSON de firewall
    json {
      source => "message"
    }
    
    # Detectar escaneo de puertos
    if [packet_count] > 50 {
      mutate {
        add_tag => ["port_scan", "network_attack"]
        add_field => { "threat_type" => "port_scan" }
      }
    }
    
    # Detectar conexiones a puertos sensibles
    if [dst_port] in [22, 23, 3389, 1433, 3306, 5432] {
      mutate {
        add_tag => ["sensitive_port"]
        add_field => { "port_risk" => "high" }
      }
    }
    
    # GeoIP para IPs externas
    if [src_ip] !~ /^(10\.|192\.168\.|172\.(1[6-9]|2[0-9]|3[01])\.)/ {
      geoip {
        source => "src_ip"
        target => "src_geoip"
      }
    }
  }
  
  else if [log_type] == "auth" {
    # Parsear logs JSON de autenticación
    json {
      source => "message"
    }
    
    # Detectar ataques de fuerza bruta
    if [result] == "FAILED" {
      mutate {
        add_tag => ["auth_failure"]
      }
      
      # Contar fallos por IP (simplificado)
      if [username] in ["admin", "root", "administrator"] {
        mutate {
          add_tag => ["admin_brute_force", "auth_attack"]
          add_field => { "threat_type" => "brute_force" }
        }
      }
    }
    
    # GeoIP lookup
    geoip {
      source => "src_ip"
      target => "geoip"
    }
  }
  
  else if [log_type] == "system" {
    # Parsear logs JSON de sistema
    json {
      source => "message"
    }
    
    # Detectar procesos sospechosos
    if [process_name] in ["powershell.exe", "cmd.exe", "nc.exe", "wget.exe"] {
      mutate {
        add_tag => ["suspicious_process", "system_attack"]
        add_field => { "threat_type" => "suspicious_execution" }
      }
    }
    
    # Detectar escalación de privilegios
    if [event_type] == "privilege_escalation" {
      mutate {
        add_tag => ["privilege_escalation", "system_attack"]
        add_field => { "threat_type" => "privilege_escalation" }
      }
    }
  }
  
  else if [log_type] == "dns" {
    # Parsear logs JSON de DNS
    json {
      source => "message"
    }
    
    # Detectar dominios sospechosos
    if [query] =~ /(?i)(evil|malware|phishing|suspicious|attacker)/ {
      mutate {
        add_tag => ["malicious_domain", "dns_attack"]
        add_field => { "threat_type" => "malicious_dns" }
      }
    }
    
    # Detectar consultas DNS anómalas
    if [response_code] in ["NXDOMAIN", "REFUSED"] {
      mutate {
        add_tag => ["dns_failure"]
      }
    }
  }
  
  # Enriquecimiento común para todos los logs
  
  # Agregar información de tiempo
  date {
    match => [ "timestamp", "ISO8601", "yyyy-MM-dd'T'HH:mm:ss.SSSZ", "dd/MMM/yyyy:HH:mm:ss Z" ]
    target => "@timestamp"
  }
  
  # Calcular hash del evento para deduplicación
  fingerprint {
    source => ["message", "source_ip", "timestamp"]
    target => "event_hash"
    method => "SHA256"
  }
  
  # Agregar severidad basada en tags
  if "web_attack" in [tags] or "network_attack" in [tags] or "auth_attack" in [tags] or "system_attack" in [tags] or "dns_attack" in [tags] {
    mutate {
      add_field => { "severity" => "HIGH" }
      add_field => { "alert_required" => "true" }
    }
  } else if "client_error" in [tags] or "auth_failure" in [tags] or "dns_failure" in [tags] {
    mutate {
      add_field => { "severity" => "MEDIUM" }
    }
  } else {
    mutate {
      add_field => { "severity" => "LOW" }
    }
  }
  
  # Limpiar campos innecesarios
  mutate {
    remove_field => ["message", "ident", "auth", "rawrequest", "params"]
  }
}

output {
  # Enviar a Elasticsearch para indexado
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    user => "elastic"
    password => "password"
    index => "security-logs-%{+YYYY.MM.dd}"
    template_name => "security-logs"
    template_pattern => "security-logs-*"
    template => "/usr/share/logstash/templates/security-logs-template.json"
  }
  
  # Enviar logs procesados a Kafka para ML
  kafka {
    bootstrap_servers => "kafka:29092"
    topic_id => "processed-security-logs"
    codec => json
  }
  
  # Enviar alertas de alta severidad directamente
  if [severity] == "HIGH" {
    kafka {
      bootstrap_servers => "kafka:29092"
      topic_id => "security-alerts"
      codec => json
    }
  }
  
  # Debug output (comentar en producción)
  # stdout { codec => rubydebug }
}